<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.553">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2023-11-03">

<title>Pingjian Ding - Basic Git Commands</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Pingjian Ding</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../researches.html"> 
<span class="menu-text">Researches</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../publications.html"> 
<span class="menu-text">Publications</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../courses.html"> 
<span class="menu-text">Courses</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../blogs.html"> 
<span class="menu-text">Blogs</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../contact.html"> 
<span class="menu-text">Contact</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
          <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#introduction" id="toc-introduction" class="nav-link active" data-scroll-target="#introduction">Introduction</a></li>
  <li><a href="#list-of-basic-git-commands" id="toc-list-of-basic-git-commands" class="nav-link" data-scroll-target="#list-of-basic-git-commands">List of Basic Git Commands</a></li>
  <li><a href="#detailed-examples-on-github" id="toc-detailed-examples-on-github" class="nav-link" data-scroll-target="#detailed-examples-on-github">Detailed Examples on GitHub</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Basic Git Commands</h1>
<p class="subtitle lead">Git, (In Chinese)</p>
</div>



<div class="quarto-title-meta">

    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">November 3, 2023</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<p><a href="https://git-scm.com/doc">Source</a></p>
<p><a href="https://www.bilibili.com/video/BV1HM411377j/?p=12&amp;spm_id_from=pageDriver&amp;vd_source=018aff571b2b18387e912fbb0863d036">Source: bilibili</a></p>
<section id="introduction" class="level2">
<h2 class="anchored" data-anchor-id="introduction">Introduction</h2>
<table class="table">
<colgroup>
<col style="width: 3%">
<col style="width: 96%">
</colgroup>
<thead>
<tr class="header">
<th>文件、状态、区域</th>
<th>类别</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>四个区域</td>
<td>1. 工作区（working directory）：就是你在电脑里实际看到的目录；<br> 2. 暂存区（stage/index）：暂存区也叫索引，用来临时存放未提交的内容，一般在.git目录下的index中；<br> 3. 本地仓库（repository）：Git在本地的版本库，仓库信息存储在.git这个隐藏目录中；<br> 4. 远程仓库（Remote Repository）：托管在远程服务器上的仓库。常用的有GitHub、GitLab、Gitee。</td>
</tr>
<tr class="even">
<td>文件状态</td>
<td>1. 已修改（Modified）：修改了但是没有保存到暂存区的文件；<br> 2. 已暂存（Staged）：修改后已经保存到暂存区的文件；<br> 3. 已提交（Committed）：把暂存区的文件提交到本地仓库后的状态。</td>
</tr>
<tr class="odd">
<td>状态</td>
<td>1. main/master：默认主分支 <br>2. Origin：默认远程仓库 <br>3. HEAD：指向当前分支的指针 <br>4. HEAD^：上一个版本 <br>5. HEAD~：上四个版本</td>
</tr>
<tr class="even">
<td>特殊文件</td>
<td>1. .git：Git仓库的元数据和对象数据库 <br>2. .gitignore：忽略文件，不需要提交到仓库的文件 <br>3. .gitattributes：指向当前分支的指针 <br>4. .gitkeep：使空目录被提交到仓库 <br>5. .gitmodules：记录子模块的信息 <br>6. .gitconfig：记录仓库的配置信息</td>
</tr>
<tr class="odd">
<td>GitFlow</td>
<td>1. 主分支（master/main）：代表了项目的稳定版本，每个提交到主分支的代码都应该是经过测试和审核的；<br>2. 开发分支（develop）：用于日常开发。所有的功能分支、发布分支和修补分支都应该从开发分支派生出来；<br>3. 功能分支（feature）：用于开发单独的功能或者特性。每个功能分支都应该从开发分支派生，并在开发完成后合并回开发分支；<br>4. 发布分支（release）：用于准备项目发布。发布分支应该从开发分支派生，并在准备好发布版本后合并回主分支和开发分支；<br>5. 热修复分支（hotfix）：用于修复主分支上的紧急问题。热修复分支应该从主分支派生，并在修复完成后，合并回主分支和开发分支。</td>
</tr>
</tbody>
</table>
</section>
<section id="list-of-basic-git-commands" class="level2">
<h2 class="anchored" data-anchor-id="list-of-basic-git-commands">List of Basic Git Commands</h2>
<table class="table">
<colgroup>
<col style="width: 5%">
<col style="width: 14%">
<col style="width: 80%">
</colgroup>
<thead>
<tr class="header">
<th>类别</th>
<th>Command</th>
<th>Usage</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>初始化设置</strong></td>
<td><code>git config --global user.name "Your Name"</code></td>
<td>配置用户名</td>
</tr>
<tr class="even">
<td></td>
<td><code>git config --global user.email "mail@example.com"</code></td>
<td>配置邮箱</td>
</tr>
<tr class="odd">
<td></td>
<td><code>git config --global credential store</code></td>
<td>存储配置</td>
</tr>
<tr class="even">
<td><strong>创建仓库</strong></td>
<td><code>git init &lt;project-name&gt;</code></td>
<td>创建一个新的本地仓库（省略project-name则在当前目录创建）</td>
</tr>
<tr class="odd">
<td></td>
<td><code>git clone &lt;url&gt;</code></td>
<td>克隆一个远程仓库</td>
</tr>
<tr class="even">
<td><strong>分支</strong></td>
<td><code>git branch</code></td>
<td>查看所有本地的分支，当前分支前面会有一个星号*，<code>-r</code>查看远程分支，<code>-a</code>查看所有分支。</td>
</tr>
<tr class="odd">
<td></td>
<td><code>git branch &lt;branch-name&gt;</code></td>
<td>创建一个新的分支</td>
</tr>
<tr class="even">
<td></td>
<td><code>git checkout -b &lt;branch-name&gt;</code></td>
<td>切换到指定分支，并更新工作区</td>
</tr>
<tr class="odd">
<td></td>
<td><code>git branch -d &lt;branch-name&gt;</code></td>
<td>删除一个已经合并的分支</td>
</tr>
<tr class="even">
<td></td>
<td><code>git checkout -D &lt;branch-name&gt;</code></td>
<td>删除一个分支，不管是否合并</td>
</tr>
<tr class="odd">
<td></td>
<td><code>git tag &lt;tag-name&gt;</code></td>
<td>给当前的提交打上标签，通常用于版本发布</td>
</tr>
<tr class="even">
<td></td>
<td><code>git merge --no-ff -m message &lt;branch-name&gt;</code></td>
<td>合并分支，–no-ff参数表示禁用FastForward模式，合并后的历史有分支，能看出曾经做过的合并，而-ff参数表示使用FastForward模式，合并后的历史会变成一条直线</td>
</tr>
<tr class="odd">
<td></td>
<td><code>git squash &lt;branch-name&gt;</code></td>
<td>合并&amp;挤压（squash）所有提交到一个提交</td>
</tr>
<tr class="even">
<td></td>
<td><code>git switch &lt;branch-name&gt;</code></td>
<td>Git switch is a command introduced in Git version 2.23 as a replacement for branch switching, providing better safety checks and usability.</td>
</tr>
<tr class="odd">
<td></td>
<td><code>git checkout &lt;branch-name&gt;</code></td>
<td>git checkout is a versatile command used not only for branch switching but also for file and commit operations.</td>
</tr>
<tr class="even">
<td></td>
<td><code>git rebase &lt;main&gt;</code></td>
<td><code>rebase</code>操作可以把本地未<code>push</code>的分叉提交历史整理成直线，看起来更加直观。但是，如果多人协作时，不要对已经推送到远程的分支执行<code>rebase</code>操作。<code>rebase</code>不会产生新的提交，而是把当前分支的每一个提交都”复制”到目标分支上，然后再把当前分支指向目标分支，而<code>merge</code>会产生一个新的提交，这个提交有两个分支的所有修改。</td>
</tr>
<tr class="odd">
<td><strong>撤销和恢复</strong></td>
<td><code>git mv &lt;file&gt; &lt;new-file&gt;</code></td>
<td>移动一个文件到新的位置</td>
</tr>
<tr class="even">
<td></td>
<td><code>git rm &lt;file&gt;</code></td>
<td>从工作区和暂存区删除一个文件，并且将这次删除放入暂存区</td>
</tr>
<tr class="odd">
<td></td>
<td><code>git rm --cached</code></td>
<td>从索引/暂存区中删除文件，但是本地工作区文件还在，只是不希望这个文件被版本控制。</td>
</tr>
<tr class="even">
<td></td>
<td><code>git checkout &lt;file&gt; &lt;commit-id&gt;</code></td>
<td>恢复一个文件到之前的版本</td>
</tr>
<tr class="odd">
<td></td>
<td><code>git revert &lt;commit-id&gt;</code></td>
<td>创建一个新的提交，用来撤销指定的提交，后者的所有变化将被前者抵消，并且应用到当前分支</td>
</tr>
<tr class="even">
<td></td>
<td><code>git reset --mixed &lt;commit-id&gt;</code></td>
<td>重置当前分支的HEAD为之前的某个提交，并且删除所有之后的提交。<br> –hard参数表示重置工作区的暂存区 <br> –soft参数表示重置暂存区 <br> –mixed参数表示重置工作区</td>
</tr>
<tr class="odd">
<td></td>
<td><code>git restore --staged &lt;file&gt;</code></td>
<td>撤销暂存区的文件，重新放回工作区（git add的反向操作)</td>
</tr>
<tr class="even">
<td><strong>查看状态或差异</strong></td>
<td><code>git status</code></td>
<td>查看仓库状态，列出还未提交的新的或修改的文件</td>
</tr>
<tr class="odd">
<td></td>
<td><code>git log --online</code></td>
<td>查看提交历史，–online表示简介模式</td>
</tr>
<tr class="even">
<td></td>
<td><code>git diff</code></td>
<td>查看未暂存的文件更新了哪些部分</td>
</tr>
<tr class="odd">
<td></td>
<td><code>git diff &lt;commit-id&gt; &lt;commit-id&gt;</code></td>
<td>查看两个提交之间的差异</td>
</tr>
<tr class="even">
<td><strong>Stash</strong></td>
<td><code>git status save "message"</code></td>
<td>Stash操作可以把当前工作现场”储存”起来，等以后恢复现场后继续工作。 <br> <code>-u</code>参数表示把所有未跟踪的文件也一并存储；<br> <code>-a</code>参数表示把所有未跟踪的文件和忽略的文件也一并存储；<br> <code>save</code>参数表示存储的信息，可以不写</td>
</tr>
<tr class="odd">
<td></td>
<td><code>git stash list</code></td>
<td>查看所有的stash</td>
</tr>
<tr class="even">
<td></td>
<td><code>git stash pop</code></td>
<td>恢复最近一次stash</td>
</tr>
<tr class="odd">
<td></td>
<td><code>git stash pop stash@{2}</code></td>
<td>恢复指定的stash，stash@{2}表示第三个stash，stash@{0}表示最近的stash</td>
</tr>
<tr class="even">
<td></td>
<td><code>git stash apply</code></td>
<td>重新接受最近一次stash</td>
</tr>
<tr class="odd">
<td></td>
<td><code>git stash drop stash@{2}</code></td>
<td>pop和apply的区别是，pop会把stash内容删除，而apply不会。可以使用git stash drop来删除stash</td>
</tr>
<tr class="even">
<td></td>
<td><code>git stash clear</code></td>
<td>删除所有stash</td>
</tr>
<tr class="odd">
<td><strong>远程仓库</strong></td>
<td><code>git remote add &lt;remote-name&gt; &lt;remote-url&gt;</code></td>
<td>添加远程仓库</td>
</tr>
<tr class="even">
<td></td>
<td><code>git remote -v</code></td>
<td>查看远程仓库</td>
</tr>
<tr class="odd">
<td></td>
<td><code>git remote rm &lt;remote-name&gt;</code></td>
<td>删除远程仓库</td>
</tr>
<tr class="even">
<td></td>
<td><code>git remote rename &lt;old-name&gt; &lt;new-name&gt;</code></td>
<td>重命名远程仓库</td>
</tr>
<tr class="odd">
<td></td>
<td><code>git pull &lt;remote-name&gt; &lt;branch-name&gt;</code></td>
<td>从远程仓库拉取代码。默认拉取远程仓库名origin的master或者main分支</td>
</tr>
<tr class="even">
<td></td>
<td><code>git pull --rebase</code></td>
<td>将本地改动的代码rebase到远程仓库的最新代码上（为了有一个干净、线性的提交历史）</td>
</tr>
<tr class="odd">
<td></td>
<td><code>git push &lt;remote-name&gt; &lt;branch-name&gt;</code></td>
<td>推送代码到远程仓库（然后再发起pull request）</td>
</tr>
<tr class="even">
<td></td>
<td><code>git fetch &lt;remote-name&gt;</code></td>
<td>获取所有远程分支</td>
</tr>
<tr class="odd">
<td></td>
<td><code>git branch -r</code></td>
<td>查看远程分支</td>
</tr>
<tr class="even">
<td></td>
<td><code>git fetch &lt;remote-name&gt; &lt;branch-name&gt;</code></td>
<td>Fetch某一个特定的远程分支</td>
</tr>
</tbody>
</table>
</section>
<section id="detailed-examples-on-github" class="level2">
<h2 class="anchored" data-anchor-id="detailed-examples-on-github">Detailed Examples on GitHub</h2>
<table class="table">
<colgroup>
<col style="width: 3%">
<col style="width: 96%">
</colgroup>
<thead>
<tr class="header">
<th>Examples</th>
<th>Steps</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>将GitHub代码仓库下载本地</td>
<td>1. 首先你在GitHub上创建一个仓库：然后给这个仓库添加你的ssh密匙，这一步大家可以参考网上教程，可以去百度搜索：“如何给GitHub创建仓库和添加ssh” <br>2. 进入仓库，选择code下的ssh复制按钮。 <br>3. 在本地新建一个空白文件夹用于下载GitHub代码仓库（ps:必须保证是空的文件夹） <br>4. 在该文件目录下右键选择”Git bash here” <br>5. 输入pwd查看当前位置是否为你所建立的空白文件夹位置，却无误后输入：git clone 加上你复制的SSH密匙。比如:<code>git clone git@github.com:KDDing/GLP1R_Private.git</code> <br>6. 完成从GitHub上下载代码仓库</td>
</tr>
<tr class="even">
<td>将在GitHub上更改的内容同步到本地</td>
<td>1. 在给GitHub上修改完后记得保存 (commit changes on GitHub web) <br>2. 进入你建立的文件夹，右键git bash here <br>3. 输入pwd确认位置后，输入<code>git pull origin</code> <br>4. 查看本地是否更新</td>
</tr>
<tr class="odd">
<td>将本地更新后的代码上传到GitHub</td>
<td>1. 更改本地文件 <br>2. 在文件夹下右键git bash here,输入pwd确认位置 <br>3. 输入<code>git add .</code> <br>4. 输入<code>git commit -m 'update'</code> <br>5. 输入<code>git push</code> <br>6. 打开GitHub查看是否成功</td>
</tr>
<tr class="even">
<td>关联本地仓库和远程仓库</td>
<td>1. <code>git remote add origin git\@github.com:geekhall-laoyang/first-repo.git</code> <br>2. <code>git branch -M main</code> <br>3. <code>git push -u origin main</code></td>
</tr>
<tr class="odd">
<td>Relieve file folder with Git repository</td>
<td><code>find . -name ".git" | xargs rm -Rf</code></td>
</tr>
<tr class="even">
<td>Ignoring Files</td>
<td>Often, you’ll have a class of files that you don’t want Git to automatically add or even show you as being untracked. These are generally automatically generated files such as log files or files produced by your build system. In such cases, you can create a file listing patterns to match them named <code>.gitignore</code>. Here is an example <code>.gitignore</code> file: <br> 1. <code>cat .gitignore</code> <br>2. <code>*.[oa]</code> <br>3. <code>*~</code> <br> The first line tells Git to ignore any files ending in “.o” or “.a” — object and archive files that may be the product of building your code. The second line tells Git to ignore all files whose names end with a tilde (~), which is used by many text editors such as Emacs to mark temporary files. You may also include a log, tmp, or pid directory; automatically generated documentation; and so on. Setting up a .gitignore file for your new repository before you get going is generally a good idea so you don’t accidentally commit files that you really don’t want in your Git repository.</td>
</tr>
</tbody>
</table>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
      &nbsp;
    </div>   
    <div class="nav-footer-center">
<p>Copyright 2023, Pingjian Ding</p>
</div>
    <div class="nav-footer-right">
      &nbsp;
    </div>
  </div>
</footer>




</body></html>